|    first     |   second    |   third    |
|:-------------|:---------|:-----------|
|[字符串](#p1)|[数组](#p2)|[广义表](#p3)|

<span id="p1">**字符串**</span>

*字符串的定义*

~~~cpp
typedef struct{
    char ch[MAXSLEN+1];  //字符串的一维数组
    int length;          //表示字符串当前的位置
}SString;
~~~

*串的链式存储结构*

~~~cpp
typedef struct Chunk{
    char ch[CHUNKSIZE];
    struct Chunk *next;
}Chunk;

typedef struct{
    Chunk *head,*tail;   //串的头指针与尾指针
    int Curlen;          //串的当前长度
}LString;                //字符串的块状结构
~~~


*BF算法*

~~~cpp
int Index_BF(SString S,SString T)
{
    int i=1,j=1;
    while(i<=S.length&&j<=T.length)
    {
        if(s.ch[i]==t.ch[j])  //主串和子串依次匹配下一给字符
        {
            ++i;
            ++j;
        }
        else  //主串和子串指针回溯重新开始下一次匹配
        {
            i=i-j+2;
            j=1;
        }
    }
    if(j>=T.length)  //返回匹配的第一个字符的下标
    return i-T.length;
    else
    return 0;
}
//如果想从选定的一段开始
//加上一个pos 并使i=pos
int Index_BF(SString S,SString T,int pos)
{
    int i=pos,j=1;
    while(i<=S.length&&j<=T.length)
    {
        if(s.ch[i]==t.ch[j])  //主串和子串依次匹配下一给字符
        {
            ++i;
            ++j;
        }
        else  //主串和子串指针回溯重新开始下一次匹配
        {
            i=i-j+2;
            j=1;
        }
    }
    if(j>=T.length)  //返回匹配的第一个字符的下标
    return i-T.length;
    else return 0;
}
~~~

*KMP算法*

![image](https://github.com/HellowJasper/Jasper-data-structure/assets/130765164/939107df-88d8-48d7-8bc9-85df64bf6000)


~~~cpp

~~~





