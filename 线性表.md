### 线性表 ~从零开始的数据结构的学~

|     first       |   second      |   third    |       fourth   |
|:----------------|:--------------|:-----------|:----------------|
|[顺序线性表](#p1)|[单链表](#p2)  |[双链表](#p3)|[案例分析](#p4)  | 

|            |                            顺序表                            |                             链表                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  存储空间  |              预先分配，可能会导致空间闲置或溢出              |              动态分配，不会出现空间闲置或者溢出              |
|  存储密度  |       存储密度为1，逻辑关系等于存储关系，没有额外开销        |     存储密度小于1，要借助指针域来表示元素之间的逻辑关系      |
|  存取元素  |           随机存取，按位置访问元素的时间复杂度O(1)           |         顺序存取，访问某位置的元素的时间复杂度为O(n)         |
| 插入、删除 | 插入和删除都要移动大量的元素。平均移动元素约为表的一半。时间复杂度O(n) | 不需要移动元素，只需要改变指针位置，继而改变结点之间的链接关系。时间复杂度O(1) |
|  适用情况  | 1.表长变化不大，或者事先就能确定变化的范围<br />2.很少进行插入和删除，需要下标访问元素 |            1.长度变化较大<br />2.频繁的插入和删除            |
|            |                 *这不就是vector的使用特点吗*                 |                  *这不就是list的使用特点吗*                  |

<span id="p1">**==1.这就是顺序线性表==**</span>


*线性表的定义*

~~~cpp
typedef struct SQList
{
    ElemType  *elem; // 顺序线性表的表头
    int length;     // 顺序线性表的长度
}SqList;
~~~
<div> ElemType 类似于一个房子，具体怎么定义看自己而定 使用的时候 typedef --- ElemType</div>

*线性表的初始化*

~~~cpp
int initList(SqList &L)
{
    
    L.elem = new ElemType[Maxsize];  //在堆区开辟内存
    if (!L.elem)
        exit(OVERFLOW);
    L.length = 0; //将线性表的长度设置为0
    return OK;
}
~~~

<div> OVERFLOW 已经在之前通过define定义为-2<br>OK则通过define定义为1</div>  

*线性表的销毁*

~~~cpp
void DestroyList(SqList &L)
{
    
    if (L.elem)
    {
        delete L.elem;
    }
}
~~~

*线性表的清空*

~~~cpp
void ClearList(SqList &L)
{
    
    L.length = 0;
}
~~~

*获得线性表的长度*

~~~cpp
int GetLength(SqList L)
{

    return (L.length);
}
~~~

*判断线性表是否为空*

~~~cpp

int IsEmpty(SqList L)
{

    if (L.length == 0)
        return 1;
    else
        return 0;
}
~~~

*线性表的取值*

~~~cpp
bool GetElem(SqList L, const size_t i, ElemType &e)
{

    if (i < 1 || i > L.length)
        return ERROR;

    e = L.elem[i - 1];
    return OK;
}
~~~

*线性表的查找*

~~~cpp
int LocateElem(SqList L, Elemtype e)
{

    for (int i = 0; i < L.length; i++)
    {
        if (L.elem[i] == e)
            return i + 1;        //查找成功，返回查找元素的第一个下标值
    }
    return 0;   //找不到对应的元素，返回0
}
~~~

*线性表的插入*

~~~cpp
bool ListInsert_Sq(SqList &L, int i, ElemType e)
{
    if (i < 1 || i>Ll.length + 1)  //看看要插入的是否处于线性表内
        return ERROR;
    if (L.length == MAXSIZE)  //如果长度与MAXSIZE相等那说明已经没有位置可以插入了
        return ERROR;

//经过了两次的判定后 开始操作 将插入位置之后的元素依次向后挪动一位
    for (int j = L.length - 1; j >= i - 1; j--)
        L.elem[j + 1] = L.elem[j];
//插入我们想要插入的元素
    L.elem[i - 1] = e;
//线性表的长度增加一位
    L.length++;
}
~~~

*线性表的删除*

~~~cpp
bool ListDelete_Sq(SqList &L, int i)
{
//第一步开始特判是否这个数据在线性表内
    if ((i < 1) || (i > L.length))
        return ERROR;
    for(int j = i; j <= L.length - 1; j++)  //将位于删除位置之后的元素依次向前挪动一位
        
    L.elem[j - 1] = L.elem[j];
//线性表的长度-1
    L.length--;

    return OK;
}
~~~

<span id="p2">**==单向链表==**</span>




