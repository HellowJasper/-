### 线性表 ~从零开始的数据结构的学习生活~

|     first       |   second      |   third    |       fourth   |
|:----------------|:--------------|:-----------|:----------------|
|[顺序线性表](#p1)|[单链表](#p2)  |[双链表](#p3)|[案例分析](#p4)  | 

|            |                            顺序表                            |                             链表                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  存储空间  |              预先分配，可能会导致空间闲置或溢出              |              动态分配，不会出现空间闲置或者溢出              |
|  存储密度  |       存储密度为1，逻辑关系等于存储关系，没有额外开销        |     存储密度小于1，要借助指针域来表示元素之间的逻辑关系      |
|  存取元素  |           随机存取，按位置访问元素的时间复杂度O(1)           |         顺序存取，访问某位置的元素的时间复杂度为O(n)         |
| 插入、删除 | 插入和删除都要移动大量的元素。平均移动元素约为表的一半。时间复杂度O(n) | 不需要移动元素，只需要改变指针位置，继而改变结点之间的链接关系。时间复杂度O(1) |
|  适用情况  | 1.表长变化不大，或者事先就能确定变化的范围<br />2.很少进行插入和删除，需要下标访问元素 |            1.长度变化较大<br />2.频繁的插入和删除            |
|            |                 *这不就是vector的使用特点吗*                 |                  *这不就是list的使用特点吗*                  |

<span id="p1">**==1.这就是顺序线性表==**</span>


*线性表的定义*

~~~cpp
typedef struct SQList
{
    ElemType  *elem; // 顺序线性表的表头
    int length;     // 顺序线性表的长度
}SqList;
~~~
<div> ElemType 类似于一个房子，具体怎么定义看自己而定 使用的时候 typedef --- ElemType</div>

*线性表的初始化*

~~~cpp
int initList(SqList &L)
{
    
    L.elem = new ElemType[Maxsize];  //在堆区开辟内存
    if (!L.elem)
        exit(OVERFLOW);
    L.length = 0; //将线性表的长度设置为0
    return OK;
}
~~~

<div> OVERFLOW 已经在之前通过define定义为-2<br>OK则通过define定义为1</div>  

*线性表的销毁*

~~~cpp
void DestroyList(SqList &L)
{
    
    if (L.elem)
    {
        delete L.elem;
    }
}
~~~

*线性表的清空*

~~~cpp
void ClearList(SqList &L)
{
    
    L.length = 0;
}
~~~

*获得线性表的长度*

~~~cpp
int GetLength(SqList L)
{

    return (L.length);
}
~~~

*判断线性表是否为空*

~~~cpp

int IsEmpty(SqList L)
{

    if (L.length == 0)
        return 1;
    else
        return 0;
}
~~~

*线性表的取值*

~~~cpp
bool GetElem(SqList L, const size_t i, ElemType &e)
{

    if (i < 1 || i > L.length)
        return ERROR;

    e = L.elem[i - 1];
    return OK;
}
~~~

*线性表的查找*

~~~cpp
int LocateElem(SqList L, Elemtype e)
{

    for (int i = 0; i < L.length; i++)
    {
        if (L.elem[i] == e)
            return i + 1;        //查找成功，返回查找元素的第一个下标值
    }
    return 0;   //找不到对应的元素，返回0
}
~~~

*线性表的插入*

~~~cpp
bool ListInsert_Sq(SqList &L, int i, ElemType e)
{
    if (i < 1 || i>Ll.length + 1)  //看看要插入的是否处于线性表内
        return ERROR;
    if (L.length == MAXSIZE)  //如果长度与MAXSIZE相等那说明已经没有位置可以插入了
        return ERROR;

//经过了两次的判定后 开始操作 将插入位置之后的元素依次向后挪动一位
    for (int j = L.length - 1; j >= i - 1; j--)
        L.elem[j + 1] = L.elem[j];
//插入我们想要插入的元素
    L.elem[i - 1] = e;
//线性表的长度增加一位
    L.length++;
}
~~~

*线性表的删除*

~~~cpp
bool ListDelete_Sq(SqList &L, int i)
{
//第一步开始特判是否这个数据在线性表内
    if ((i < 1) || (i > L.length))
        return ERROR;
    for(int j = i; j <= L.length - 1; j++)  //将位于删除位置之后的元素依次向前挪动一位
        
    L.elem[j - 1] = L.elem[j];
//线性表的长度-1
    L.length--;

    return OK;
}
~~~

<span id="p2">**==单向链表==**</span>

*链表的定义*

~~~cpp
typedef strut Lnode{
    ElemType data;
    struct Lnode *next;
}Lnode,*LinkList;//嵌套的定义
~~~

<div> 一个简单的例子</div>

~~~cpp
/*typedef Strurct stdent{
    char num[8];
    char name[8];
    int score;
    struct student *next;
}Lnode,*LinkList;

这种方法不是很常用
*/
typedef Struct{
    char num[8];  //数据域
    char name[8]; //数据域
    int score;    //数据域
}Elemtype;

typedef struct Lnode{
    ElemType data;       //数据域
    struct Lnode *next;  //指针域
}Lnode,*LinkList;
~~~
*单链表的初始化*

~~~cpp
Status initList_L(LinkList &L) //插入题外话：LinkList &L等价于 Lnode *&L，Lnode *&L是一个指向指针的引用
{
    L=new LNode;   //在堆区开辟处一个头节点，节点的数据类型为Lnode   L=(LinkList)malloc(sizeof(LNode));这种也可以
    L->next=NULL; //头节点指向为空
    return OK;
}

~~~

*判断链表是否为空*

~~~cpp
//判断链表是否为空

int  ListEmpty(LinkList L)
{
    if(L->next) //非空
      return 0;
    else        //空
      return 1;
}

~~~

*如何销毁一个单链表*

~~~cpp
Status DestroyList_L(LinkList &l)
{
    Lnode *p; //或LinkList p；
    while(L)
    {
        p=L;
        L=L->next;
        delete p;
    }

    return OK;

}
~~~

*清空链表*

~~~cpp
Status ClearList_L(LinkList &L)    //将L重置为空表
{
    Lnode *p,*q;    //或者LinkList p，q；
    p=L->next;      //先将此时p指向首元节点
    while(p)                 //没到表尾
    {
        q=p->next;    //接着q等于p指向的l的下下一个节点
        delete p;     //删除掉p 也就是第一个头节点
        p=q;          //将q的值传给p
    }
    L->next=NULL;    //头指针节点指针域为空
    return OK;
}
~~~

*求链表的表长*

~~~cpp
Status LengthList_L(LinkList &L)
{
    int i = 0;
    LinkList p;
    p=L->next;  //指向第一个节点
    while(p){
     i++;
     p=p->next;
    }
   return i；
}

**
~~~cpp
Status GetElem_L(LinkList &L,int i,ElemType &e)
{
    LinkList p;
    p=L->next;   //初始化
    int j=1;
    while(P&&j<i)  //向后扫描，直到p指向第i给元素或者p为空
    {
        p=p->next;
        ++j;
    }
    if(!P||j>i) return ERROR;  //第i给元素不存在
    e=p->data; //取第i给元素

    return OK;
}
~~~

*单链表的查找运算*

~~~cpp
Lnode *LocateElem_L(LinkList L,ELemtype e){
    LinkList p;
    p=L->next;
    while(p&&p->nextdata!=e)
        p=p->next;
        
        return p;
    
}
~改进的~
int LocateElem_L(LinkList L,Elemtype e){
    LinkList P;

    p=L->next;

    j=1;

    whiel(p&&p->next!=e)
    {
        p=p->next;
        j++;
    }
    if(P) return j;
    else return 0;
}
~~~

*单链表的插入*

~~~cpp
Status LinkInsert_L(LinkList &L,int i,ElemType e){

    LinkList p;
    p=L;
    j=0;
    while(p&&j<i-1)
    {
        p=p->next;
        ++j;
    } //寻找i-1个节点，p指向i-1个节点
    if(!p||j>i-1) return ERROR;
    s=new Lnode;
    s->data=e;
    s->next=p->next;
    p->next=s;

    return OK;
}
~~~

*单链表节点的删除*

~~~cpp
Status LinkDelete_L(LinkList &L,int i,ElemType e)  //i为要删除的位置
{
    LinkList p,q;
    p=L;
    int j=0;
    while(p&&j<i-1)
    {
        P=p->next;
        ++j;
    }  //寻找第i给节点

    if(!(p->next)||j>i-1)  //删除不在区间内的
    return ERROR;
    q=p->next;     //临时保存被删除节点的地址等着被释放
  
    p->next=q->next;   //改变删除节点的前驱节点的指针域
    
    e=q->next;     //保存要删除的节点的数据域
    
    delete q;    //删除节点
    
    return OK;


}
~~~

